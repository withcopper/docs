    let RequestDismissedRequestIdKey = "request_id"
    let DeviceRemoveDeviceIdKey = "device_id"
    
    extension SocketIOClient:CopperSocket {
        
    }
    
    var ANIMATION_DURATION: Double {
        return AppSettings.animationDuration
    }
    
    class CopperSession: NSObject {
        
        enum Event:String {
            case Connect = "connect"
            case Error = "error"
            case Reconnect = "reconnect"
            case Message = "message"
            case Request = "request"
            case RequestDismissed = "request_dismissed"
            case DeviceAdd = "device_add"
            case DeviceRemove = "device_remove"
            case RecordsUpdateAvailable = "records_update_available"
    private func startSocketIO() {
        // shttps://github.com/socketio/socket.io-client-swift/tree/swift-2
        if let authToken = user?.secureSettings.authToken {
            let socketURL = "copper-sockets.herokuapp.com"
            let options = ["token":authToken]
            if CopperTestEnvironment.environment.isTesting {
                self.socket = FakeSocket(socketURL:socketURL, opts: options)
            } else {
                self.socket = SocketIOClient(socketURL:socketURL, opts: options)
            }
            
            socket!.on(Event.Connect.rawValue) { data, ack in
                CopperLog(.Debug, "Socket.IO >> connected")
                CopperNetworkActivityRegistry.sharedRegistry.activityEnded()
            }
            
            socket!.on(Event.Error.rawValue) { data, ack in
                CopperNetworkActivityRegistry.sharedRegistry.activityBegan()
                CopperLog(.Warning, "Socket.IO >> errors - data: \(data)")
                
                guard let errorEscapedJsonString = data?[0] as? String else {
                    return
                }
                // Socket.io will return errors in escaped JSON string
                // like: "Error: [{\"message\":\"jwt expired\",\"code\":\"invalid_token\",\"type\":\"UnauthorizedError\"}]"
                // So lets inspect for that
                // TODO we should break this down as actual JSON into an NSDictionary but it comes through as an escaped json string from the socket IO server we use and requires some special handling to get into an NSDict -- that's work we are going to avoid for now :)
                if errorEscapedJsonString.contains("invalid_token") {
                    // force a login attempt
                    self.user?.secureSettings.authToken = nil
                    self.startSocketIO()
                }
            }
            
            socket!.on(Event.Reconnect.rawValue) { data, ack in
                CopperNetworkActivityRegistry.sharedRegistry.activityBegan()
                CopperLog(.Debug, "Socket.IO >> reconnected")
            }
            
            // We expect this to be sent by the server immediately after .connect (above)
            socket!.on(Event.Message.rawValue) { data, ack in
                CopperLog(.Debug, "Socket.IO >> welcome message: \(data)")
            }
            
            socket!.on(Event.Request.rawValue) { data, ack in
                CopperNetworkActivityRegistry.sharedRegistry.activityBegan()
                CopperLog(.Debug, "Request: \(data)")
                if let requestDict = data?[0] as? NSDictionary {
                    let response = Request.fromDictionary(requestDict)
                    if let request = response.request {
                        CopperLog(.Debug, ">>> socket.io: Request Received: \(request.id)")
                        CopperNetworkActivityRegistry.sharedRegistry.activityEnded()
                        self.requestStack.push(request, display: true)
                        ack?("Request successfully received", "\(request.id)")
                    } else {
                        var infoDict = [String:AnyObject]()
                        if let d = response.error?.dictionary {
                            infoDict = d
                        }
                        CopperLogWithRemote(.Error, error: Error.SocketIORequestReceiptError.nserror, infoDict: infoDict)
                    }
                }
            }
            
            // Our goal here is to dismiss a currently displayed request if it happens to be dismissed from the server (e.g. security, or the user dismisses a modal on desktop)
            socket!.on(Event.RequestDismissed.rawValue) { data, ack in
                if let requestIdObject = data?[0] as? NSDictionary {
                    if let requestId = requestIdObject[RequestDismissedRequestIdKey] as? String {
                        CopperLog(.Debug, ">>> socket.io: Request Dismissed: \(requestId)")
                        dispatch_async(dispatch_get_main_queue()){
                            NSNotificationCenter.defaultCenter().postNotificationName(CopperSessionDidReceiveDismissFromServerNotification, object: nil, userInfo: [RequestDismissedRequestIdKey:requestId])
                        }
                        if let request = self.requestStack.getRequest(requestId) {
                            // Set this as responded to so it never pops back up in the UI
                            self.requestStack.addResponded(request)
                        }
                    }
                }
            }
            
            socket!.on(Event.DeviceAdd.rawValue) { data, ack in
                if let deviceObject = data?[0] as? NSDictionary {
                    if let device = UserDevice.fromDictionary(deviceObject) {
                        CopperLog(.Debug, ">>> socket.io: User Device added: \(device.deviceId)")
                        self.user?.addUserDevice(device)
                    }
                }
            }
            
            socket!.on(Event.DeviceRemove.rawValue) { data, ack in
                if let deviceRemoveObject = data?[0] as? NSDictionary {
                    if let deviceId = deviceRemoveObject[DeviceRemoveDeviceIdKey] as? String {
                        CopperLog(.Debug, ">>> socket.io: User Device remove: \(deviceId)")
                        self.user?.removeUserDevice(deviceId)
                    }
                }
            }
            
            socket!.on(Event.RecordsUpdateAvailable.rawValue) { data, ack in
                CopperLog(.Debug, ">>> socket.io: Record Update Available")
                self.user?.refreshUserRecords()
            }
